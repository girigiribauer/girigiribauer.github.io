<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="/css/github-markdown.css" type="text/css" media="all">
    <link rel="stylesheet" href="/css/style.css" type="text/css" media="all">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://girigiribauer.com/index.xml">
    <title>Ansible - ばうあーろぐ</title>
    <meta property="og:title" content="Ansible - ばうあーろぐ">
    <meta property="og:type" content="article">
    <meta name="description" content="Webテクノロジーに関するメモ、あるいはTwentyFour">
    <meta property="og:description" content="Webテクノロジーに関するメモ、あるいはTwentyFour">
    <meta property="og:url" content="http://girigiribauer.com/tags/ansible/">
    <meta property="fb:app_id" content="396423247105258">
    <meta property="og:image" content="http://girigiribauer.com/img/ogimage.png">
<meta name="generator" content="Hugo 0.17" />
  </head>
  <body>

<div class="markdown-body">
<header>
<a href="/">ばうあーろぐ TOP へ戻る</a>
</header>


<div class="maincontents">

<h1>Tags / Ansible</h1>

<div class="poststatus">
  <p>  <time datetime="2016年11月29日">2016年11月29日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/ansible/">Ansible</a></li>
    <li class="flow"><a href="/tags/docker/">Docker</a></li>
    <li class="flow"><a href="/tags/vagrant/">Vagrant</a></li>
  </ul>
</div>




<p>メモとして残しておきます。</p>

<h2 id="ansible-playbook-で急に表示できなくなった">ansible-playbook で急に表示できなくなった</h2>

<p>本番環境の CentOS7 と、その検証環境（Vagrant on Mac）で
Ansible 経由で Docker をインストールして使っていたのですが、
ある日 <code>ansible-playbook</code> を実行すると急に表示できなくなりました。</p>

<p>（Chef を使ってたころはこういうの頻発してたなあ・・・）</p>

<p>その間は Vagrant のアップデートくらいしかしてなかったので、
順に確認していくことに。</p>

<h3 id="各種ログ">各種ログ</h3>

<p>nginx-proxy のログは</p>

<pre><code>lrwxrwxrwx 1 root root   11 Aug 24 03:51 access.log -&gt; /dev/stdout
lrwxrwxrwx 1 root root   11 Aug 24 03:51 error.log -&gt; /dev/stderr
</code></pre>

<p>のような感じで、特に何も指定してなければ外にログとして出るようになってます。</p>

<p><code>docker logs -f nginx-proxy</code> などとしてログを表示させたりしても特に問題は見受けられず。</p>

<p>また、 /etc/nginx/conf.d/default.conf のファイルも特に問題なく、
コンテナが作られると適切に設定が書き換わっているようでした。</p>

<h3 id="自動と手動">自動と手動</h3>

<p>次に ansible のレイヤーで問題が起きている可能性を考えて、
自動で作った Docker コンテナをそのまま手動で作ってみました。</p>

<p>するとコンソールに見慣れないメッセージが。</p>

<pre><code>WARNING: IPv4 forwarding is disabled. Networking will not work.
</code></pre>

<p>なんだこれ。</p>

<h3 id="本番環境と検証環境">本番環境と検証環境</h3>

<p>さらに、本番環境と検証環境とで同様にコンテナを作って比較してみると、
上記メッセージは表示されずに、問題なくコンテナが作成されました。</p>

<h3 id="最後にググる">最後にググる</h3>

<p>ここまでくるとローカルの環境に何かしら問題が起きた可能性があるので、
先ほどのメッセージも加味して調べると、以下のような情報が引っかかりました。</p>

<p><a href="http://chrisgilmerproj.github.io/ubuntu/network/docker/2013/09/05/ipv4-forwarding-and-docker.html" target="_blank">http://chrisgilmerproj.github.io/ubuntu/network/docker/2013/09/05/ipv4-forwarding-and-docker.html</a></p>

<p>どうやら <code>sysctl</code> コマンドでカーネルパラメータを変更して、
IPv4 を有効にしてやる必要があるようなのですが、
正直どうしてこうなった感が満載です。</p>

<p>うーん・・・今まで問題なく動作していたんですが。
（とはいえ、ここから先の原因追求は不毛なのでやめておきます。）</p>

<p>ローカルの VM にのみ起きる問題であるため、こちらについては Ansible で行おうとせず、
その手前の Vagrantfile で VM を作る段階で差分を吸収することにします。</p>

<pre><code>config.vm.define &quot;vmname&quot; do |node|
  # for docker networking
  node.vm.provision &quot;shell&quot;, :inline =&gt; &quot;sudo sysctl -w net.ipv4.ip_forward=1&quot;, run: &quot;always&quot;
end
</code></pre>

<h3 id="おまけ">おまけ</h3>

<p>調べる途中で nginx-proxy のログのタイムゾーンが UTC だったので、
これなんとかならんかなーと思って少し寄り道して調べてたのですが、
スマートな方法があったのでついでに。</p>

<p><a href="http://qiita.com/ganta/items/a0f34866c994ebaeef69" target="_blank">http://qiita.com/ganta/items/a0f34866c994ebaeef69</a></p>

<p>docker run するときにホストの /etc/localtime をコンテナの /etc/localtime にバインドしてやれば良かったのでした。</p>

<blockquote>
<p>-v /etc/localtime:/etc/localtime:ro</p>
</blockquote>

<p>なんで思いつかなかったんだろう。すごくシンプルで良いです。</p>


<ul class="socialbuttons">
  <li class="flow">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja" data-count="vertical">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
  </li>
  <li class="flow">
    <div class="fb-like" data-layout="button" data-action="like" data-size="small" data-show-faces="false" data-share="false"></div>
  </li>
  <li class="flow">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  </li>
</ul>

<div class="poststatus">
  <p>  <time datetime="2016年11月29日">2016年11月29日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/ansible/">Ansible</a></li>
    <li class="flow"><a href="/tags/docker/">Docker</a></li>
    <li class="flow"><a href="/tags/vagrant/">Vagrant</a></li>
  </ul>
</div>

<small>もし記事内に誤りなどございましたら、 <a href="https://twitter.com/girigiribauer" target="_blank">@girigiribauer</a> までご一報いただけると助かります。</small>

<div class="poststatus">
  <p>  <time datetime="2016年9月12日">2016年9月12日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/ansible/">Ansible</a></li>
    <li class="flow"><a href="/tags/jinja2/">jinja2</a></li>
  </ul>
</div>




<p>これも公式に詳しく書いてなくて出来るのを分かってなかったので
僕と同じようなところで困っている人のためにメモっておきます。</p>

<h2 id="jinja2">jinja2</h2>

<p>Ansible では jinja2 というテンプレートエンジンが利用されています。</p>

<p>playbook 内で <code>{{ ssh_port }}</code> などの記述を埋め込むことで
外部の設定ファイルから ssh_port の値を環境に応じて出し分けることが可能です。</p>

<p>僕の場合は、ローカル（VirtualBox + Vagrant）環境と本番環境とで
設定値が異なるところを括り出して、Ansible の group_vars ディレクトリ以下に
環境ごとのファイル名をつけて保存しています。</p>

<p>Ansible 関係なく、jinja2 のテンプレートエンジンの解説ページが
以下にあります。</p>

<p><a href="http://jinja.pocoo.org/docs/dev/templates/" target="_blank">http://jinja.pocoo.org/docs/dev/templates/</a></p>

<p>こちらを見ると分かるように、Ansible の playbook 以外にも
HTML や XML などにも幅広く利用されているようです。</p>

<p>デリミタ（delimiter、区切り文字のこと）の種類として、以下の4つが使えるものとして挙げられています。</p>

<ul>
<li>{% &hellip; %} for Statements</li>
<li>{{ &hellip; }} for Expressions to print to the template output</li>
<li>{# &hellip; #} for Comments not included in the template output</li>
<li>#  &hellip; ## for Line Statements</li>
</ul>

<p>このうち、Ansible の playbook でよく使われるのが <code>{{ ... }}</code> の式の実行結果が出力できるやつで、
それ以外のものは公式のドキュメントにはほぼ見かけません。</p>

<h2 id="ansible-における条件分岐">Ansible における条件分岐</h2>

<p>Ansible で条件分岐できる方法はもちろんあるのですが、
when の中に記述する形のようです。
<a href="http://docs.ansible.com/ansible/playbooks_conditionals.html" target="_blank">http://docs.ansible.com/ansible/playbooks_conditionals.html</a> から抜粋します。</p>

<pre><code>tasks:
    - shell: echo &quot;I've got '{{ foo }}' and am not afraid to use it!&quot;
      when: foo is defined

    - fail: msg=&quot;Bailing out. this play requires 'bar'&quot;
      when: bar is undefined
</code></pre>

<p>僕がやりたいのはこういうのではなくて（これでもコピペ増やせばできなくはなさそうだけど）、
環境変数を条件によって出し分けたいのです。例えばこんな感じ。</p>

<p>（group_vars 以下のファイルが tls: False のとき）</p>

<pre><code>env:
  port: 80
</code></pre>

<p>（group_vars 以下のファイルが tls: True のとき）</p>

<pre><code>env:
  port: 443
</code></pre>

<p>これを例えば以下のようにやってしまうと、エラーになってしまいます。</p>

<pre><code>env:
{% if tls %}
  port: 443
{% else %}
  port: 80
{% endif %}
</code></pre>

<p>先ほどの jinja2 のドキュメントの方を参考にすれば、
こういった書き方もいけそうな気がするのですが、
どうやら jinja2 のテンプレートとして評価をする前に、
Ansible 側で <strong>YAML の（設定）ファイルとして Valid かどうかをチェック</strong> しているらしいです。</p>

<p>なので、上記のような書き方は出来ず、
あくまでこういったデリミタなしで YAML として成立してなくてはいけません。</p>

<p>一方で、<code>{{ ... }}</code> を埋め込むときは、文字列として <code>&quot;{{ ... }}&quot;</code> と囲むことが多いのですが、
文字列であれば YAML のチェックは通ります。</p>

<pre><code>env:
  port: &quot;{% if tls %}443{% else %}80{% endif %}&quot;
</code></pre>

<p>上記のようにあくまで YAML のファイルで文字列が入ってますよーという風にすれば問題ないっぽいですね。</p>

<p>ちょっと不恰好ではありますが、
group_vars 以下の設定項目が冗長になるよりはだいぶマシかと思います。
（tls を false に変更したら、 port の項目も 443 から 80 に併せて変更、みたいなやつ）</p>

<h2 id="まとめ">まとめ</h2>

<p>Ansible の playbook を書くときは、</p>

<ol>
<li><strong>まず YAML として成立させる</strong></li>
<li><strong>{% &hellip; %} の埋め込みは文字列の中にまとめて入れる</strong></li>
</ol>

<p>とやれば問題なさそうです。</p>

<p>不安であれば <code>ansible-playbook</code> の出力時に <code>-vvvv</code> などとつけてパラメータを確認すると良いかもしれません。</p>

<h2 id="ref">参考URL</h2>

<ul>
<li><a href="http://jinja.pocoo.org/docs/dev/templates/" target="_blank">http://jinja.pocoo.org/docs/dev/templates/</a></li>
<li><a href="http://docs.ansible.com/ansible/playbooks_conditionals.html" target="_blank">http://docs.ansible.com/ansible/playbooks_conditionals.html</a></li>
</ul>


<ul class="socialbuttons">
  <li class="flow">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja" data-count="vertical">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
  </li>
  <li class="flow">
    <div class="fb-like" data-layout="button" data-action="like" data-size="small" data-show-faces="false" data-share="false"></div>
  </li>
  <li class="flow">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  </li>
</ul>

<div class="poststatus">
  <p>  <time datetime="2016年9月12日">2016年9月12日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/ansible/">Ansible</a></li>
    <li class="flow"><a href="/tags/jinja2/">jinja2</a></li>
  </ul>
</div>

<small>もし記事内に誤りなどございましたら、 <a href="https://twitter.com/girigiribauer" target="_blank">@girigiribauer</a> までご一報いただけると助かります。</small>

<div class="poststatus">
  <p>  <time datetime="2016年9月7日">2016年9月7日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/ansible/">Ansible</a></li>
    <li class="flow"><a href="/tags/docker/">Docker</a></li>
  </ul>
</div>




<p><a href="http://girigiribauer.com/archives/20160906/" target="_blank">Ansible で再起動後にも playbook を継続する方法</a> で
再ログインに関しても一緒にまとめておこうと思ったのですが、
Docker の方が話の割合として多くなりそうだったので別記事でまとめておきます。
特に Ansible で Docker をインストールするときはこれに該当するんじゃないかと思います。</p>

<h2 id="ansible-で-docker">Ansible で Docker</h2>

<p>まず話がややこしくならないように事前に触れておきますが、
Ansible &amp; Docker の話は複数あって、</p>

<ol>
<li>Ansible の playbook の実行（の検証？）に Docker コンテナを用いる話</li>
<li>Ansible の playbook で Docker をインストールする話</li>
</ol>

<p>が挙げられますが、今回は 1 ではなく 2 の話です。</p>

<p>ちなみに 1 についてですが、
例えばローカルに用意した VirtualBox や外部に借りている VPS の環境だったり、
SSH がつながる環境であれば Ansible の実行は可能ですが、
それが Docker コンテナまで利用できるように広がってきたよという話です。
（僕も詳しくないのでここまでしか把握してません。）</p>

<p>詳しくは &ldquo;ansible docker connection plugin&rdquo; でおググりください。</p>

<h2 id="docker-インストール時のグループ追加について">Docker インストール時のグループ追加について</h2>

<p>手動でやっててけっこうはまった箇所なのですが、
<strong>各種 docker コマンドを実行する際は、sudo をつけて実行するか、
docker グループにユーザーを追加してから docker コマンドを実行する必要があります。</strong></p>

<p>Ansible 実行ユーザーを docker グループに追加し Docker 関連の操作をさせる際に、
Ansible の playbook を Ansible 実行ユーザー自身が実行中なため、
<strong>一度ログインし直してグループに追加したことを設定反映する必要があります。</strong></p>

<p>つまり、Docker インストール用の playbook を実行して、
ansible ユーザーを docker グループに入れたからといって、
docker_image, docker_container モジュールを用いた playbook は動作しません。</p>

<p>予め手動で ansible ユーザーを docker グループに入れた直後にログアウトせず、
そのまま <code>docker ps</code> などを実行してみると、</p>

<pre><code>$ sudo usermod -aG docker ansible
$ docker ps
Cannot connect to the Docker daemon. Is the docker daemon running on this host?
</code></pre>

<p>というメッセージが出て Docker 周りの操作は何もできません。
（id -a などでグループに追加されているか確認しても、自分自身はログアウトしない限り追加されてません）</p>

<h2 id="docker-インストール用-playbook">Docker インストール用 playbook</h2>

<p>Ansible 実行ユーザー（ここでは ansible）を
docker グループに入れたまま docker コマンドが操作できる playbook を書いてみました。</p>

<p>仕組みとしては前回の <a href="http://girigiribauer.com/archives/20160906/" target="_blank">Ansible で再起動後にも playbook を継続する方法</a> と同じで
local_action を用いてログアウト後に待機します。</p>

<p>またまた抜粋ですみません・・・。改めてまとめなおします。</p>

<pre><code>- name: Docker 用 yum リポジトリの追加
  yum_repository:
    name: dockerrepo
    description: Docker Repository
    baseurl: https://yum.dockerproject.org/repo/main/centos/$releasever/
    enabled: yes
    gpgkey: https://yum.dockerproject.org/gpg
    gpgcheck: yes
  tags: dockerhost
  become: True

- name: docker-engine のインストール
  yum: name=docker-engine enablerepo=dockerrepo state=latest
  tags: dockerhost
  become: True

- name: docker-python のインストール
  yum: name=docker-python enablerepo=dockerrepo state=latest
  tags: dockerhost
  become: True

- name: Docker 起動時の DNS 設定
  copy: src=&quot;docker&quot; dest=&quot;/etc/sysconfig/docker&quot; owner=ansible group=ansible mode=0400
  tags: dockerhost
  become: True

- name: Docker サービス自動起動設定
  service: name=docker state=running enabled=True
  tags: dockerhost
  become: True

- name: Docker グループにユーザー追加
  user: name=ansible groups=docker append=yes
  tags: dockerhost
  become: True

- name: Ansible 実行ユーザー自身のグループ状況の取得
  shell: id -a
  register: group_status
  changed_when: False
  tags: dockerhost

- name: Docker グループ追加後の再ログイン
  shell: &quot;sleep 2 &amp;&amp; pkill -u ansible sshd&quot;
  async: 1
  poll: 0
  when: group_status.stdout.find('docker') == -1
  tags: dockerhost
  become: True

- name: Docker グループ追加後の再ログイン完了まで待機
  local_action: wait_for host={{ inventory_hostname }} port={{ ssh_port }} delay=10
  when: group_status.stdout.find('docker') == -1
  tags: dockerhost
  become: False

- name: Docker コマンドが Ansible 実行ユーザーで使えるかテスト
  shell: docker version
  changed_when: False
  tags: dockerhost
  become: False
</code></pre>

<p>docker-python と python-docker-py は多分同じパッケージなんじゃないかと思われます。
yum info を見てみると、どちらも docker が提供してるので、
単に <code>yum install docker</code> でインストールして入るであろう docker-python の方を指定しています。
（Ansible のドキュメントには docker-py が必要とありましたが、docker-python で問題なかったです）</p>

<pre><code>$ yum info docker-python
読み込んだプラグイン:fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirror.nus.edu.sg
 * extras: mirror.vodien.com
 * updates: mirror.vastspace.net
利用可能なパッケージ
名前                : docker-python
アーキテクチャー    : x86_64
バージョン          : 1.4.0
リリース            : 115.el7
容量                : 94 k
リポジトリー        : extras/7/x86_64
要約                : An API client for docker written in Python
URL                 : http://www.docker.com
ライセンス          : ASL 2.0
説明                : An API client for docker written in Python

$ yum info python-docker-py
読み込んだプラグイン:fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirror.nus.edu.sg
 * extras: mirror.vodien.com
 * updates: mirror.vastspace.net
インストール済みパッケージ
名前                : python-docker-py
アーキテクチャー    : noarch
バージョン          : 1.7.2
リリース            : 1.el7
容量                : 235 k
リポジトリー        : installed
提供元リポジトリー  : extras
要約                : An API client for docker written in Python
URL                 : https://github.com/docker/docker-py/
ライセンス          : ASL 2.0
説明                : An API client for docker written in Python
</code></pre>

<p>前回と同様に、実行するかどうかのステータスを取得して、
必要なければスキップするようになっています。</p>

<p>また、local_action と wait_for モジュールの組み合わせで再度 ssh でつなぎにいくのを待機しつつ検知しています。
最後の <code>docker version</code> では、実際にコマンドが有効かどうかを実行して確かめています。
仕組みとしては大きく前回と違いはありません。</p>

<h2 id="まとめ">まとめ</h2>

<p>まだ Docker ホストとして動作するまでしか用意してないので、
アプリケーションなどは特に動いてませんが、
開発用途であれ、サービス用途であれ、
これからはコンテナを中心とした環境にかなり移行していくと思うので、
<strong>Docker ホストとして最低限動作するところまでは playbook として共通化できる</strong> と思います。</p>

<p>ここまでやっておくと残りは Docker イメージや Docker コンテナの操作が中心になってきますね。</p>

<p>まだ、playbook は現時点でごちゃごちゃせずにすっきりしている（と個人的には思っている）ので、
docker-compose を導入せずにこのまま Ansible で Docker の構成管理してもいいんじゃないかとも思っています。</p>

<p>ちなみに、言うまでも無いことですが、
手動でセットアップできないのに Docker や Ansible を使えば知識なしに出来るわけはないので、
まずは空っぽの環境を用意して手動でやってみることをお勧めします。</p>

<h2 id="ref">参考URL</h2>

<ul>
<li><a href="https://docs.docker.com/engine/installation/linux/centos/" target="_blank">https://docs.docker.com/engine/installation/linux/centos/</a></li>
<li><a href="https://docs.ansible.com/ansible/docker_container_module.html" target="_blank">https://docs.ansible.com/ansible/docker_container_module.html</a></li>
<li><a href="https://github.com/ansible/ansible-modules-core/issues/921" target="_blank">https://github.com/ansible/ansible-modules-core/issues/921</a></li>
</ul>


<ul class="socialbuttons">
  <li class="flow">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja" data-count="vertical">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
  </li>
  <li class="flow">
    <div class="fb-like" data-layout="button" data-action="like" data-size="small" data-show-faces="false" data-share="false"></div>
  </li>
  <li class="flow">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  </li>
</ul>

<div class="poststatus">
  <p>  <time datetime="2016年9月7日">2016年9月7日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/ansible/">Ansible</a></li>
    <li class="flow"><a href="/tags/docker/">Docker</a></li>
  </ul>
</div>

<small>もし記事内に誤りなどございましたら、 <a href="https://twitter.com/girigiribauer" target="_blank">@girigiribauer</a> までご一報いただけると助かります。</small>

<div class="poststatus">
  <p>  <time datetime="2016年9月6日">2016年9月6日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/ansible/">Ansible</a></li>
    <li class="flow"><a href="/tags/automation/">automation</a></li>
  </ul>
</div>




<p>タイトルの通りですが、正直これ出来ないと思っていたので、出来てすごく嬉しいです。</p>

<p>Chef では少なくともそういった機能は無かったように思えますが（僕が知らないだけかもしれない）、
<strong>Ansible はプッシュベース</strong> だからでしょうか。
実行する主体がいつもローカル側にあるからこそ、
一旦接続を切ってまた繋げるといったことがやりやすいのかもしれません。</p>

<h2 id="そもそもなぜ再接続したいのか">そもそもなぜ再接続したいのか？</h2>

<p>ほとんどの playbook では問題ないのですが、
SELinux の設定の反映（一時的な設定だけなら問題なし）などの一部のセットアップにて、
<strong>再起動が必要になるものが存在しています。</strong></p>

<p>他にもあるかもしれませんが、
例えば SELinux の設定をいじる場合は以下のような手順を踏みます。</p>

<pre><code>$ getenforce #=&gt; 今の設定確認
Enforcing
$ sudo vi /etc/sysconfig/selinux #=&gt; SELINUX=disabled を設定
$ sudo reboot #=&gt; 再起動
</code></pre>

<p>Ansible では playbook 上で reboot すると、
<strong>playbook のステータスが unreachable になってそのまま終了</strong> してしまいます。</p>

<pre><code>fatal: [machine_name]: UNREACHABLE! =&gt; {&quot;changed&quot;: false, &quot;msg&quot;: &quot;Failed to connect to the host via ssh.&quot;, &quot;unreachable&quot;: true}
</code></pre>

<p>繋がらなくなるのでまあ当然ですよね。</p>

<p>これを一連の playbook で再起動をはさんで実行できると、
playbook を書くときにトリッキーなことをせずに済むこともあるかもしれません。
（SELinux だけみると、最後にまとめて再起動すれば事足りるっちゃあそうですが・・・。）</p>

<p>ちょっと話が逸れますが、 reboot するのが通常の task ではなく handler だった場合、
（handler は変化があった場合のみ、最後にまとめて実行するタスクのこと）
単に再起動だけ実行させて、あとはほったらかしで問題ないケースも出てきます。
その場合は playbook の実行完了を待たない poll の値を設定することで、handler で再起動をさせて終了させることは可能です。</p>

<p><a href="http://docs.ansible.com/ansible/playbooks_async.html" target="_blank">http://docs.ansible.com/ansible/playbooks_async.html</a></p>

<h2 id="再接続を可能にする-ansible-のモジュール">再接続を可能にする Ansible のモジュール</h2>

<p>Ansible で再接続を行うために必要な関連モジュールをメモっておきます。
最初のやつは正確にはモジュールではないかもしれません。キーワード？</p>

<h3 id="local-action">local_action</h3>

<p><a href="http://docs.ansible.com/ansible/playbooks_delegation.html" target="_blank">http://docs.ansible.com/ansible/playbooks_delegation.html</a></p>

<p>この local_action は他のモジュールと同じように使うことが出来るのですが、
モジュールのさらに頭につけることで
<strong>ローカルに処理を委譲することができます。</strong></p>

<p>ちなみに <code>delegate_to</code> というキーワードも存在していて、以下は同じ意味を指すようです。
（先ほどのリンク内から抜粋）</p>

<pre><code>- name: add back to load balancer pool
command: /usr/bin/add_back_to_pool {{ inventory_hostname }}
delegate_to: 127.0.0.1

- name: take out of load balancer pool
local_action: command /usr/bin/take_out_of_pool {{ inventory_hostname }}
</code></pre>

<h3 id="wait-for-モジュール">wait_for モジュール</h3>

<p><a href="http://docs.ansible.com/ansible/wait_for_module.html" target="_blank">http://docs.ansible.com/ansible/wait_for_module.html</a></p>

<p>wait_for モジュールは、 <strong>指定したホスト名・ポートを監視し、有効になるまで待機します。</strong></p>

<p>先に非同期で再起動するような playbook を用意しておき、
その後 local_action をはさんだ wait_for モジュールを利用して、
再起動で処理が戻るまで待機するような playbook を書くことが可能です。</p>

<h3 id="set-fact-モジュール">set_fact モジュール</h3>

<p><a href="http://docs.ansible.com/ansible/set_fact_module.html" target="_blank">http://docs.ansible.com/ansible/set_fact_module.html</a></p>

<p>set_fact モジュールは、ansible-playbook の <strong>実行時の変数を途中で上書きできるモジュール</strong> です。</p>

<p>今回は結局使わなかったのですが、
例えばポート番号を変えたり、パスワード認証から公開鍵認証に変えたりした場合に、
接続するための情報を途中で変更する際に用いました。</p>

<p>あくまで僕のケースですが、個人的には接続方法が大きく変わった時には無理をせず、
強制的に fail などのメッセージを出して（鍵認証に変えたから接続し直してね的なやつ）、
変更後の接続方法で改めて playbook を実行するようにしています。
（この辺の話はまた長くなるので、余裕があれば改めて取りまとめたいですね・・・）</p>

<h2 id="selinux-の-playbook">SELinux の playbook</h2>

<p>他 playbook も参考にしながら、冪等性も踏まえて書いてみたのがこれです。
（抜粋＆本筋じゃないところは省略）</p>

<pre><code>- name: SELinux のステータス取得
  shell: getenforce
  register: selinux_status
  changed_when: False
  tags: selinux
  become: True

- name: SELinux をコントロールするためのパッケージ導入
  yum: name=libselinux-python state=installed
  when: selinux_status.stdout == 'Enforcing'
  tags: selinux
  become: True

- name: SELinux の無効化
  selinux: state=disabled
  when: selinux_status.stdout == 'Enforcing'
  tags: selinux
  become: True

- name: SELinux 設定後の再起動
  shell: &quot;sleep 2 &amp;&amp; reboot&quot;
  async: 1
  poll: 0
  when: selinux_status.stdout == 'Enforcing'
  tags: selinux
  become: True

- name: SELinux 設定後の再起動完了まで待機
  local_action: wait_for host={{ inventory_hostname }} port={{ ssh_port }} delay=30
  when: selinux_status.stdout == 'Enforcing'
  tags: selinux
  become: False
</code></pre>

<p>inventory_hostname は <a href="http://docs.ansible.com/ansible/playbooks_variables.html" target="_blank">http://docs.ansible.com/ansible/playbooks_variables.html</a> にあるように
Ansible のインベントリファイルがあるローカルを指しています。予め用意されている変数です。</p>

<p>register については
<a href="http://docs.ansible.com/ansible/playbooks_conditionals.html#register-variables" target="_blank">http://docs.ansible.com/ansible/playbooks_conditionals.html#register-variables</a> にありますが、
実行結果などを後で参照するために一時保存してくれる機能です。</p>

<p>SELinux の設定を取得して、有効になっていた場合のみ無効となるような playbook を実行しています（冪等性）。
逆に <strong>2回目以降の playbook の実行ですでに無効になっていた場合は、
when と書いてあるところが False になるので playbook の実行がスキップされます。</strong>
毎回再起動をはさんでいては時間がかかってしまいますので、
時間短縮のため register や when などを用いて変更する必要があるときだけ処理をするようにしています。</p>

<p>ちなみに、再起動自体の playbook ですが、
sleep 2 や async: 1 がないと一番最初の例と同じく unreachable でストップしてしまいます。
shell モジュール内で sleep 2 などを頭につけて実行直後に再起動が実行されないようにしつつ、
async でこの playbook の終了タイミング自体も直後ではなく後ろにずらす必要がありました。</p>

<p>様々な環境で試したところ、両方ずらす必要があるようです。
最初は単にタイミングをずらすだけで良いかと思って sleep 1 になってたんですが、
Vagrant 上は問題がなくとも VPS 上では sleep 2 にしないと unreachable になってしまったりと、
再起動周りは多少経験則が必要なようです・・・。</p>

<p>ここに関しては内部の処理を見たわけではないのですが、
タイミングをずらすことで、再起動の処理の前に
次の local_action &amp; wait_for モジュールに処理を渡してから再起動を行う必要があるようです。</p>

<h2 id="まとめ">まとめ</h2>

<p>Ansible のプッシュベースであるメリットが出てて便利だなーと思います。</p>

<p>再起動の playbook については、今まで問題があったわけではないのですが、
selinux の部分だけで設定完了することになるので、
playbook の依存関係が少しすっきりした気がします。
ただ、再起動タスクが多ければ多いほど、
最後にまとめて handler として実行した方が playbook 全体の処理時間は短くなると思います。</p>

<p>あと playbook の書き順によっては接続ポートの変更とかぶった場合、
<strong>再起動後に SSH のポートが変わっちゃって接続できなくなっちゃった、</strong> みたいなケースもありうるので
そこは注意が必要かと思います。（今回使っていないset_fact モジュールである程度いけるかと思います）</p>

<p>ちなみに再起動に関してはこの記事の通りなのですが、
再ログインに関してはまだまとめきれてないので、
改めて記事にメモっておこうと思います。</p>

<h2 id="ref">参考URL</h2>

<ul>
<li><a href="http://qiita.com/volanja/items/d38fe0678848bae6902f" target="_blank">http://qiita.com/volanja/items/d38fe0678848bae6902f</a></li>
<li><a href="https://gyagya1111.blogspot.jp/2015/02/ansibleselinux.html" target="_blank">https://gyagya1111.blogspot.jp/2015/02/ansibleselinux.html</a></li>
<li><a href="http://jinja.pocoo.org/docs/dev/templates/" target="_blank">http://jinja.pocoo.org/docs/dev/templates/</a></li>
<li><a href="http://stackoverflow.com/questions/23877781/how-to-wait-for-server-restart-using-ansible" target="_blank">http://stackoverflow.com/questions/23877781/how-to-wait-for-server-restart-using-ansible</a></li>
</ul>


<ul class="socialbuttons">
  <li class="flow">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja" data-count="vertical">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
  </li>
  <li class="flow">
    <div class="fb-like" data-layout="button" data-action="like" data-size="small" data-show-faces="false" data-share="false"></div>
  </li>
  <li class="flow">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  </li>
</ul>

<div class="poststatus">
  <p>  <time datetime="2016年9月6日">2016年9月6日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/ansible/">Ansible</a></li>
    <li class="flow"><a href="/tags/automation/">automation</a></li>
  </ul>
</div>

<small>もし記事内に誤りなどございましたら、 <a href="https://twitter.com/girigiribauer" target="_blank">@girigiribauer</a> までご一報いただけると助かります。</small>

<div class="poststatus">
  <p>  <time datetime="2016年8月16日">2016年8月16日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/chef/">Chef</a></li>
    <li class="flow"><a href="/tags/ansible/">Ansible</a></li>
  </ul>
</div>




<p>前の記事の <a href="/archives/20160705/">WordPress を捨てて Hugo に移行した</a> よりも前に、
ずいぶん前に &ldquo;Chef を捨てて Ansible に移行&rdquo; していたのですが、
書いておかないと忘れるので自分用にメモしておきます。</p>

<h2 id="プロビジョニングツールを使い始める前の自分">プロビジョニングツールを使い始める前の自分</h2>

<p>Chef を利用する前は、
いわゆる <strong>プロビジョニングツール</strong> というのものを一切使っておらず、
サーバの構築はそのマシンでうまく行くまで何度も行う、
トライアンドエラーのようなサーバ構築を行っておりました。</p>

<p>こういうのって、ちゃんとコマンドラインで入力した内容をメモるなりして
きちんと手順化していかないと、
すぐに忘れたりして環境の再現ができなかったりするんですよね。</p>

<p>最初は実機に対して直接作業を行うことが多かったので、
普段慣れない端末への入力だったり、異なる OS でのオペレーションなども相まって
上手くインストールできないと結構なストレスを感じることも多くありました。</p>

<p>そのうち、実機にそのまま試すのではなく、サンドボックスのような自由に試せる環境を
予め用意し、まずはそっちで試してみようと思い、 <strong>VirtualBox + Vagrant</strong> を導入して
自分のマシン上に対象となる Linux マシンと同一の環境を作り、
先にそちらで試すようになりました。</p>

<p>それと同時に、非常に簡易的ではありますが、
<strong>シェルスクリプトベース</strong> の手順書のようなものを自分で用意するようになり、
よくある一般的なサーバのセットアップ作業程度であれば
素早く再現できるようになりました。</p>

<p>ここまで来てようやく <strong>サーバのセットアップ手順をまとめることへの重要性</strong> に
段々と気づくようになってきます。</p>

<h2 id="chef-を導入し使い始めたころの自分">Chef を導入し使い始めたころの自分</h2>

<p>手元の環境をローカル、セットアップ対象をリモートとすると、
<strong>Chef 自体をリモートの方にインストールする必要</strong> があったのですが、
Vagrant のプラグインである vagrant-omnibus を利用して
初回起動時に自動的に Chef をインストールできたことでだいぶ楽できました。</p>

<p>Chef の Cookbook と呼ばれる手順書のファイル群を自分で書くか、
あるいは <a href="https://supermarket.chef.io/" target="_blank">https://supermarket.chef.io/</a> などで公開されている
サードパーティ製の Cookbook を利用するなどして、
シェルスクリプトベースで書かれていた秘伝のタレになりつつあった手順書を
なんとか汎用化していこうと思い、少しずつ置き換えを進めていきました。</p>

<p>みんなが当たり前に行う一般的な手順であればあるほど、
同じ Cookbook を使うはずなので（ユーザーの作成や Web サーバのインストールなど）、
こういったよくある Cookbook は可能な限り多く使われているサードパーティ製を使い、
可能な限りレールから逸れないようにしようと思い、
サードパーティ製を積極的に利用していきました。
（もちろん無条件に信用したわけではなく、利用するものはきちんと中身を吟味したうえで利用しています）</p>

<p>用意さえできれば、あとはコマンド1つで全部整うのは正直気持ちが良いですね。
手元の Vagrant 環境と、VPS 環境とで環境変数を括り出し、
異なる環境で同じ Cookbook が正しく動作するととても清々しいです。</p>

<h3 id="chef-の-cookbook-は-debian-系がほとんど">Chef の Cookbook は debian 系がほとんど</h3>

<p>運用し始めると、公開されているサードパーティ製の Cookbook は
<strong>そのほとんどが debian 系</strong> だということに気づきます。</p>

<p>実際 debian 系の方が世界ではシェアが多く、
逆に日本だけが特殊のようで（要出典、Web サーバに限った話ですかね？）
Red Hat 系の方が多いようです。
ちなみに CentOS も Red Hat 系に含まれます。</p>

<p>もちろん利用の多いサードパーティ製の Cookbook は debian 系と Red Hat 系とで
きちんと処理を分けて書かれているのですが、
中にはおまけ程度にしか用意されていない or そもそも debian 系しか用意してない
といったものもあり、かゆいところに手が届かないケースもたびたび出てきました。</p>

<h3 id="アップデート地獄">アップデート地獄</h3>

<p>運用がしばらく続くと、個々の Cookbook でアップデートが起こります。
それ以前に各種ミドルウェア、アプリケーションにおいてもアップデートは当然起こりえます。
そうなると Cookbook でバージョンの差異などが吸収しきれなくなってきて、
プロビジョニングが通らなくなるケースが出てきます。</p>

<p>問題はある程度見えていて、直接リモートのサーバを直せばすぐ解決するのですが、
手順としてまとめられているので、「直接手を出したらだめだ、手順書の意味がない・・・」と
ぐっとこらえて Cookbook の方をちまちま修正する日々が続きます。</p>

<h3 id="ruby-からくる記述の多様性">Ruby からくる記述の多様性</h3>

<p>プロビジョニングツール以外でも、変更があったときにフックとして
あれを行うといった処理がよくあるかと思いますが、
Chef においても同様の処理が用意されてます。</p>

<p>ただ、色々と利用していくうちに、記述の仕方が数多くあり、
かなり煩雑になってきてしまい若干混乱をきたしてしまってました。
まあ僕が整理して書けてないだけなんですが、整理する気が段々起きなくなってくるんですよね・・・。
変更があったときにフックしたいだけなんですけどね・・・。</p>

<h3 id="chef-zero-ってなんぞ">Chef Zero ってなんぞ・・・</h3>

<p>たぶん僕が使い方を完全にわかってないせいだと思うのですが、
一時期「これからは Chef Zero だ」みたいな風潮（？）の高まり（？）があって、
僕も空いたタイミングで重い腰をあげて Chef Zero に移行してみました。</p>

<p>結論からいうとそのまま移行せずに使ってれば良かったなーという印象です。
Chef Zero があれば Chef Server が不要でうんぬんかんぬんとか、
僕はただシェルスクリプトの手順書を置き換えたかっただけなんですけどね・・・。</p>

<h2 id="運用していくと-chef-への不満が徐々にたまる">運用していくと Chef への不満が徐々にたまる</h2>

<p>不満をまとめるとこんな感じです。</p>

<ul>
<li>debian 系しか考慮されてないのつらい</li>
<li>アップデートで容易に破綻しやすい</li>
<li>色んな書き方ありすぎじゃないの</li>
<li>もっとコンパクトに使いたい</li>
</ul>

<p>Chef 使ってる方から見ると色々とお叱り受けそうな感じですが、
一言でいうと <strong>僕にはオーバースペックすぎた</strong> んじゃないかと・・・。
（大企業でサーバたくさんあって、という状況でルール定めてやる分には非常に良いと思います）</p>

<p>不満はたまれども、サーバは動いているので保守しなくてはなりません。</p>

<p>とある日、急ぎでこれを追加でインストールしなくてはいけない、といった状況が生まれ、
時間もなく止むを得ず <strong>直接ログインしてコマンドを叩く</strong> ことに。</p>

<p><strong>はい、禁断の一手。</strong></p>

<p>その日以降、Chef コマンドは叩かれなくなり、
いよいよ代用のプロビジョニングツールを探すことになりました。</p>

<h2 id="chef-を捨てて-ansible-に移行した">Chef を捨てて Ansible に移行した</h2>

<p>ようやく Ansible の話に入っていくわけなんですが、
Ansible の良いところは以下かなーと思っています。</p>

<ul>
<li>設定がシンプル、YAML ファイルいじるだけ</li>
<li>debian 系、 Red Hat 系はそれぞれ別の playbook（手順書）を書く</li>
<li>SSH に毛が生えた程度の仕組みのシンプルさ</li>
</ul>

<p>Chef の Cookbook に対して、Ansible の手順書のファイル群は playbook と呼ばれるのですが、
これが <strong>YAML</strong> で出来ており、とてもシンプルにまとまってすっきりします。</p>

<p>これは YAML だから良いというよりも、設定ファイルであるからこそ、
用意された記述方法しか許されないという点がシンプルさに繋がっているかと思います。
（YAML が素晴らしいとは言ってません。）
Ansible でフックしたい場合は、 notify と書くしかありません。</p>

<p>Chef の時は debian 系しか用意されてない場合もあってつらかったのですが、
Ansible では yum モジュールと apt モジュールのそれぞれを用意しており、
Red Hat 系では yum モジュールを普通に使えば良いので、
そもそも playbook は最初から別モノになります。
<strong>無理に汎用化されてないので、逆に利用しやすい</strong> かなと思います。</p>

<p>あとセットアップ対象のリモートマシンに何もインストールせず、
SSH だけ動けば OK という <strong>プッシュベース</strong> なのが非常に楽でした。</p>

<h3 id="一方でローカルに若干インストールしづらいデメリットも">一方でローカルに若干インストールしづらいデメリットも</h3>

<p>リモートには Ansible をインストールする必要がない一方で、
ローカルには当然インストールする必要があります。</p>

<p>これが若干めんどくさかったのですが、
記事を書いている時点で Ansible 2.0.1.0 だったんですね。
（インストールした頃は 1.9 だったっけか）
このバージョンは、現時点での最新バージョンである 2.1 ではなく、
2.1 で入った新機能を使いたくもあったので、
Python のパッケージの依存関係に若干はまりつつも個別にインストールしました。</p>

<p>Ansible って、利用するモジュールによって追加でパッケージが必要なものもあるので
そのあたりは使っていて注意かもしれませんね。
その辺の詳しいことは各モジュールのページに書いてあります。
<a href="https://docs.ansible.com/ansible/list_of_all_modules.html" target="_blank">https://docs.ansible.com/ansible/list_of_all_modules.html</a></p>

<h3 id="おまけ-ここから-ansible-2-1-が普通に提供されてたら関係ない話">（おまけ）ここから ansible 2.1 が普通に提供されてたら関係ない話</h3>

<p>現時点で Homebrew に 2.1 が提供されていなかったので
以下を元に（当時の）最新版を入れました。</p>

<p><a href="http://docs.ansible.com/ansible/intro_installation.html#latest-releases-via-pip" target="_blank">http://docs.ansible.com/ansible/intro_installation.html#latest-releases-via-pip</a></p>

<p><strong>2016/11/21追記</strong></p>

<p>ansible 2.2 が Homebrew に来てました。
これでクソみたいなインストール作業に時間を割かなくてすみますね！</p>

<blockquote>
<p>% brew info ansible
ansible: stable 2.2.0.0 (bottled), HEAD
Automate deployment, configuration, and upgrading
<a href="https://www.ansible.com/" target="_blank">https://www.ansible.com/</a>
Not installed
From: <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb" target="_blank">https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb</a>
==&gt; Dependencies
Build: pkg-config ✘
Required: libyaml ✘, openssl@1.1 ✘
==&gt; Requirements
Required: python ✔</p>
</blockquote>

<p><strong>2016/11/21追記ここまで</strong></p>

<p>ちなみに Docker 周りは Ansible 2.1 でサポートがかなり強化されたので、
今後は 2.1 以降を入れた方が良いかもです。</p>

<p>docker_container モジュール、いいよ。</p>

<p><a href="https://www.ansible.com/blog/ansible-2.1" target="_blank">https://www.ansible.com/blog/ansible-2.1</a></p>

<p>確かこんな感じで入れたと思います。（メモが残ってたので多分これかと）</p>

<pre><code>$ curl https://bootstrap.pypa.io/ez_setup.py -o - | python
$ sudo easy_install pip
$ sudo pip install ansible
PyYAML-3.11 ansible-2.1.0.0 cryptography-1.4 jinja2-2.8 paramiko-2.0.1 pycrypto-2.6.1
</code></pre>

<p>ただ、これだと CentOS7 など一部で問題が起きるため、
ここからさらに paramiko のバージョンを 2.x から 1.x にダウングレードする必要があります。
（ややこしいのですが、ローカルに入れた ansible の依存パッケージのバージョンで
一部のリモートの環境にて問題が起きるケースがあるようです）</p>

<pre><code>sudo pip install paramiko==1.17.x
</code></pre>

<p>みたいな感じですかね。</p>

<p>詳しくは <a href="http://www.paramiko.org/changelog.html#2.0.0" target="_blank">http://www.paramiko.org/changelog.html#2.0.0</a>, <a href="http://www.paramiko.org/installing-1.x.html" target="_blank">http://www.paramiko.org/installing-1.x.html</a> などをご確認ください。</p>

<p>あるいはリモート環境に直接アクセスして、ローカルの ansible の環境に合うように
リモートの sshd_config の設定などを適宜見直すといった方法でも問題ないかと思います。
（が、リモートに接続して設定変更するのは本末転倒な気がするので僕はやりません）</p>

<p>Python のパッケージの依存関係、面倒で嫌になりますね・・・。
（対象マシンのパッケージの依存関係を解決したいがために ansible 経由で Docker を入れようとするも、
ansible のローカル側のパッケージ依存に悩まされるというこの本末転倒感・・・。）</p>

<h2 id="まとめ">まとめ</h2>

<p>まだ運用し続けているわけではないので、
これから問題が出てくる可能性も十分あるのですが、
今のところ快適に利用できています。</p>

<p>一応、Chef でやっていたローカル、リモートで変数を括り出して
同じ playbook でプロビジョニングする、といった程度は問題なく出来ています。
（ユーザー作成や SSH ポート番号の変更など）
そのうち知見たまったらまたアウトプットしたいですね。</p>

<p>ちなみに、これは Chef でも Ansible でも両方に言えることですが、
<strong>手作業でインストールできない人がプロビジョニングツールを使ったら
あら不思議、インストールできちゃったわ！なんてことはない</strong> ですし、
あったとしても後でトラブルで死ぬだけなので、ちゃんと元のコマンドを理解して
<strong>用法用量を守って正しくお使いください。</strong></p>

<h2 id="ref">参考URL</h2>

<ul>
<li><a href="http://mojavy.com/blog/2013/01/11/alc-nokogiri-tmux/" target="_blank">http://mojavy.com/blog/2013/01/11/alc-nokogiri-tmux/</a></li>
<li><a href="http://knowledge.sakura.ad.jp/tech/3084/" target="_blank">http://knowledge.sakura.ad.jp/tech/3084/</a></li>
<li><a href="http://www.sssg.org/blogs/naoya/archives/2768" target="_blank">http://www.sssg.org/blogs/naoya/archives/2768</a></li>
<li><a href="http://stackoverflow.com/questions/37426055/ansible-2-x-install-fails-due-to-paramiko-2-0-dependency-changes" target="_blank">http://stackoverflow.com/questions/37426055/ansible-2-x-install-fails-due-to-paramiko-2-0-dependency-changes</a></li>
</ul>


<ul class="socialbuttons">
  <li class="flow">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja" data-count="vertical">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
  </li>
  <li class="flow">
    <div class="fb-like" data-layout="button" data-action="like" data-size="small" data-show-faces="false" data-share="false"></div>
  </li>
  <li class="flow">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  </li>
</ul>

<div class="poststatus">
  <p>  <time datetime="2016年8月16日">2016年8月16日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/chef/">Chef</a></li>
    <li class="flow"><a href="/tags/ansible/">Ansible</a></li>
  </ul>
</div>

<small>もし記事内に誤りなどございましたら、 <a href="https://twitter.com/girigiribauer" target="_blank">@girigiribauer</a> までご一報いただけると助かります。</small>







</div>

<footer>

<h2>Tags</h2>

<ul class="tags">
  <li class="flow">
    <a href="/tags/ansible">Ansible (5)</a>
  </li>
  <li class="flow">
    <a href="/tags/apache">Apache (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/cli">CLI (10)</a>
  </li>
  <li class="flow">
    <a href="/tags/css">CSS (4)</a>
  </li>
  <li class="flow">
    <a href="/tags/css3">CSS3 (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/cssfilter">CSSfilter (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/canvas">Canvas (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/chef">Chef (9)</a>
  </li>
  <li class="flow">
    <a href="/tags/crawler">Crawler (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/dom">DOM (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/docker">Docker (5)</a>
  </li>
  <li class="flow">
    <a href="/tags/ftp">FTP (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/font">Font (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/functionallanguage">FunctionalLanguage (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/glsl">GLSL (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/git">Git (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/golang">Golang (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/html">HTML (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/html5">HTML5 (7)</a>
  </li>
  <li class="flow">
    <a href="/tags/html5-outline">HTML5-outline (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/homebrew">Homebrew (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/hugo">Hugo (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/icon-font">Icon-Font (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/javascript">JavaScript (5)</a>
  </li>
  <li class="flow">
    <a href="/tags/linux">Linux (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/mvc">MVC (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/opengraph">OpenGraph (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/php">PHP (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/rdfa">RDFa (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/ssh">SSH (4)</a>
  </li>
  <li class="flow">
    <a href="/tags/svg">SVG (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/scala">Scala (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/shellscript">ShellScript (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/smartphone">Smartphone (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/static-site-generator">Static Site Generator (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/vagrant">Vagrant (15)</a>
  </li>
  <li class="flow">
    <a href="/tags/vim">Vim (4)</a>
  </li>
  <li class="flow">
    <a href="/tags/virtualbox">VirtualBox (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/virtualization">Virtualization (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webapp">WebApp (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webaudioapi">WebAudioAPI (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webfont">WebFont (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webgl">WebGL (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webrtc">WebRTC (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webserver">WebServer (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/yeoman">Yeoman (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/zsh">Zsh (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/ajax">ajax (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/automation">automation (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/bugs">bugs (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/event-conference">event-conference (5)</a>
  </li>
  <li class="flow">
    <a href="/tags/getusermedia">getUserMedia (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/gitconfig">gitconfig (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/ios">iOS (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/iterm">iTerm (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/jquery">jQuery (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/jinja2">jinja2 (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/jq">jq (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/jsperf">jsperf (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/lint">lint (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/mediaquery">mediaQuery (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/namespace">namespace (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/oldie">oldIE (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/output">output (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/polyfills">polyfills (4)</a>
  </li>
  <li class="flow">
    <a href="/tags/preloader">preloader (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/rsync">rsync (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/tmux">tmux (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/viewport">viewport (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/vimrc">vimrc (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/virtualization">virtualization (6)</a>
  </li>
  <li class="flow">
    <a href="/tags/wget">wget (1)</a>
  </li>
</ul>

<h2>Categories</h2>

<ul>
  <li>
    <a href="/categories/tech/">Category / Tech</a>
  </li>
  <li>
    <a href="/categories/twentyfour/">Category / TwentyFour</a>
  </li>
</ul>

<h2>RSS</h2>

<ul>
  <li>
    <a href="/categories/tech/index.xml" target="_blank">RSS: Category / Tech</a>
  </li>
  <li>
    <a href="/index.xml" target="_blank">RSS: All articles</a>
  </li>
</ul>

<p>このブログは個人の見解であり、所属する組織の公式見解ではありません</p>
<p>&copy; ばうあーろぐ Generated by <a href="https://gohugo.io/" target="_blank">Hugo</a> and <a href="https://github.com/sindresorhus/github-markdown-css" target="_blank">github-markdown-css</a></p>

</footer>

</div>


<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-36767095-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>



  </body>
</html>


