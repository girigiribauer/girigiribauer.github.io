<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="/css/github-markdown.css" type="text/css" media="all">
    <link rel="stylesheet" href="/css/style.css" type="text/css" media="all">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://girigiribauer.com/index.xml">
    <title>jQuery - ばうあーろぐ</title>
    <meta property="og:title" content="jQuery - ばうあーろぐ">
    <meta property="og:type" content="article">
    <meta name="description" content="Webテクノロジーに関するメモ、あるいはTwentyFour">
    <meta property="og:description" content="Webテクノロジーに関するメモ、あるいはTwentyFour">
    <meta property="og:url" content="http://girigiribauer.com/tags/jquery/">
    <meta property="fb:app_id" content="396423247105258">
    <meta property="og:image" content="http://girigiribauer.com/img/ogimage.png">
<meta name="generator" content="Hugo 0.17" />
  </head>
  <body>

<div class="markdown-body">
<header>
<a href="/">ばうあーろぐ TOP へ戻る</a>
</header>


<div class="maincontents">

<h1>Tags / jQuery</h1>

<div class="poststatus">
  <p>  <time datetime="2014年2月12日">2014年2月12日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/dom/">DOM</a></li>
    <li class="flow"><a href="/tags/javascript/">JavaScript</a></li>
    <li class="flow"><a href="/tags/jquery/">jQuery</a></li>
    <li class="flow"><a href="/tags/polyfills/">polyfills</a></li>
  </ul>
</div>




<p>意図せずシリーズ化してしまった、前回からの続き3回目です。</p>

<ul>
<li><a href="/archives/1233/">jQuery から卒業するための第1歩を polyfills から学ぼう</a></li>
<li><a href="/archives/1254/">jQuery から卒業するための第1歩を polyfills から学ぼう – その2</a></li>
</ul>

<p><a href="https://github.com/inexorabletash/polyfill" target="_blank">https://github.com/inexorabletash/polyfill</a> にある web.js をソースコードリーディングしています。 また、es5.js は予め読み込まれている前提となります。</p>

<h2 id="selectors-api-level-1">Selectors API Level 1</h2>

<p><strong>DOM ツリー</strong>に関する polyfills です。</p>

<p><strong>Selectors API</strong> って何なのー？って思う方もいるかもしれませんが、 例えば jQuery でいう <strong>$(‘.element’)</strong> みたいなアレとほぼ同じです。</p>

<p>大まかに以下の5つに関する polyfills が用意されています。</p>

<ul>
<li>querySelectorAll</li>
<li>querySelector</li>
<li>getElementsByClassName</li>
<li>TextRectangle</li>
<li>DOM Enumerations</li>
</ul>

<h3 id="queryselectorall-queryselector">querySelectorAll, querySelector</h3>

<p><strong>querySelectorAll</strong> は、CSS のセレクタ（ .element とか #title とか）を指定して、それに<strong>当てはまる要素全てを取得</strong>できます。</p>

<p>試しに今閲覧しているブラウザで開発者ツールを開き、</p>

<pre><code>document.querySelectorAll('.entry-content h2')
</code></pre>

<p>などと入力してみると、このページの class=”entry-content” と書かれた中にある h2 の要素を一通り取得出来ていることが分かると思います。</p>

<p><img src="/img/2014/02/polyfills08.png" alt="" /></p>

<p>この <strong>querySelectorAll / querySelector は IE8 から使えることが出来る</strong>ため、 IE7 以前のブラウザでは一切動作しなくてもいい、というケースにおいては普通に使うことが出来ますね。 （とはいえ、全く動かないのもアレなので、こういった polyfills があるとより親切かと思います）</p>

<p>ただ、単に要素を取得するだけであれば、元々ある他の方法（ getElementById, getElementsByTagName など）を用いれば 同等のものが実現出来ることも容易に想像がつきます。</p>

<p>さて、181〜199行目を抜粋します。（間の空行が上手く表示できなかったので詰めています）</p>

<pre><code>if (!document.querySelectorAll) {
  document.querySelectorAll = function (selectors) {
    var style = document.createElement('style'), elements = [], element;
    document.documentElement.firstChild.appendChild(style);
    document._qsa = [];
    style.styleSheet.cssText = selectors + '{x-qsa:expression(document._qsa &amp;&amp; document._qsa.push(this))}';
    window.scrollBy(0, 0);
    style.parentNode.removeChild(style);
    while (document._qsa.length) {
      element = document._qsa.shift();
      element.style.removeAttribute('x-qsa');
      elements.push(element);
    }
    document._qsa = null;
    return elements;
  };
}
</code></pre>

<p>かなり<strong>ハック的な方法</strong>が用いられているので、正直ざっくりとしか理解できていませんが、 普通に polyfills を実現しようとすると速度面でかなり劣ることが分かっているため、 どうにかして IE7 以前でも普通に使えるレベルまでもっていけないか？という試行錯誤の跡になっています。</p>

<p>難しいので特徴だけ軽くまとめてみようかと・・・。</p>

<ul>
<li>本来の document.querySelectorAll と異なり、document._qsa などに一時的に計算結果を保存している（副作用がある）</li>
<li>CSS 内に JavaScript が書ける Expressions が使われている（IE5 で導入、セキュリティのため IE8 以降では無視される）</li>
<li>本来 Expressions を用いるとめちゃめちゃ遅くなるが、要素取得のみに限定して使うことで全体として速くなっている（らしい）</li>
</ul>

<p>（まあハックなのでこれくらいの理解でいいかなと・・・）</p>

<p>詳しくは以下に掲載されているようです。</p>

<p><a href="http://ajaxian.com/archives/creating-a-queryselector-for-ie-that-runs-at-native-speed" target="_blank">http://ajaxian.com/archives/creating-a-queryselector-for-ie-that-runs-at-native-speed</a></p>

<p>querySelector の方も、All で取得したものの頭のものを持ってくるだけなので省略します。</p>

<h3 id="getelementsbyclassname">getElementsByClassName</h3>

<p><strong>getElementsByClassName</strong> は、<strong>getElementsByTagName</strong> や <strong>getElementById</strong> と同じで 要素をクラス名で取得します。今まで無かったのが不思議ですね。</p>

<p>同じく開発者ツールを開いて、以下のように取得ができます。</p>

<p>document.getElementsByClassName(&#8216;entry-content&#8217;) （クラス名をそのまま入れるので、頭のドットは不要ですね）</p>

<p>処理の中身である210, 211行目のみ抜粋します。</p>

<p>classNames = String(classNames).replace(/^|s+/g, &#8216;.&#8217;); return document.querySelectorAll(classNames); こちらの処理も querySelector と同じく、<strong>querySelectorAll</strong> を流用して提供されています。 クラス名を受け取って、querySelectorAll に渡してやっているだけですね。</p>

<p>こちら、クラス名の指定が正しくされている時以外は、ひょっとするとエラーになるケースもあるかもしれませんが、 <strong>/^|s+/g</strong> の正規表現で、先頭かもしくはホワイトスペースが1つ以上続く場合、それを . に置き換えるようになっています。</p>

<p>普通に <strong>&#8216;toggle&#8217;</strong> みたいな文字列が指定されれば、 <strong>&#8216;.toggle&#8217;</strong> に置き換えられますし、 <strong>&#8216;aaa, bbb&#8217;</strong> のような文字列であれば、<strong>&#8216;.aaa,.bbb&#8217;</strong> に置き換えられますね。</p>

<p>※これだと、カンマの後にスペースが無いと上手く replace されないっぽいですかね？ （ひょっとすると不完全かもしれません）</p>

<h3 id="textrectangle">TextRectangle</h3>

<p>ざっと流していくだけなら比較的すらすらっと読めるのですが、 このように丁寧に順を追って見ていくと、かなり時間がかかりますね。</p>

<p>次は TextRectangle についてです。 TextRectangle が一体なんなのか、というところから書いてみます。</p>

<h4 id="textrectangle-って">TextRectangle って？</h4>

<p>とある要素に対して、「この要素の位置やサイズくださいー」と呼び出すと、以下のようなプロパティが含まれているオブジェクトが返ってきます。</p>

<pre><code>{
  bottom: 171.78125,
  height: 540,
  left: 40,
  right: 580,
  top: -368.21875,
  width: 540,
  ...
}
</code></pre>

<p>実際に、var foo = getElement… などで取得した要素に対して、</p>

<pre><code>foo.getBoundingClientRect();
</code></pre>

<p>のように、「この要素の位置やサイズくださいー」と要素に対して呼び出してやると、 <strong>TextRectangle</strong> オブジェクトが返ってきます。</p>

<p>上記をそのまま試したキャプチャです。</p>

<p><img src="/img/2014/02/polyfills09.png" alt="" /></p>

<p>真ん中に黒枠で囲まれた要素が存在していますが、それに対して <strong>getBoundingClientRect()</strong> を呼び出してやると、 その要素が上から何ピクセル、左から何ピクセル、あるいは幅が何ピクセルか、などが一通り分かります。</p>

<p>こんな感じで位置やサイズが取得でき、その返ってくるオブジェクトが <strong>TextRectangle オブジェクト</strong>です。</p>

<p>jQuery の内部でも offset（≒上、左からどんだけずれているか）などの処理で使われているようです。</p>

<h4 id="textrectangle-の-width-height-のみを補完する">TextRectangle の width, height のみを補完する</h4>

<p>ただし、この TextRectangle オブジェクトは、 ブラウザの対応度合いによって不足しているプロパティがあり、IE8 では <strong>width, height が不足</strong>しています。</p>

<p>ということで、長くなりましたが、その不足分の width, height のみを補完するためのコードが216〜221行目に相当します。</p>

<pre><code>if ('TextRectangle' in this &amp;&amp; !('width' in TextRectangle.prototype)) {
  Object.defineProperties(TextRectangle.prototype, {
    'width': { get: function() { return this.right - this.left; } },
    'height': { get: function() { return this.bottom - this.top; } }
  });
}
</code></pre>

<p>上記でだいぶ詳しく説明したので、このコードが大まかに何をやっているのかは分かると思いますが、 <strong>Object.defineProperties</strong> だけ触れておこうと思います。</p>

<h4 id="object-defineproperties-って">Object.defineProperties って？</h4>

<p><strong>Object.defineProperties(obj, props)</strong> は、ECMAScript5 (ES5) に定義されているもので、 IE9 以降からしか使えません。</p>

<p>obj に対して、props のプロパティを上書き（なければそのまま定義）することができます。</p>

<p>詳しくは MDN をご覧いただいた方が良いと思います。（毎回 MDN 見て、で済んでしまう気が・・・）</p>

<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties</a></p>

<p>jQuery にも似たような機能が用意されており、<strong>jQuery.extend</strong> で同等のことが実現出来ます。 その公式ページからの抜粋です。</p>

<pre><code>var object1 = {
  apple: 0,
  banana: { weight: 52, price: 100 },
  cherry: 97
};
var object2 = {
  banana: { price: 200 },
  durian: 100
};
// Merge object2 into object1
$.extend( object1, object2 );
</code></pre>

<p>このときに返ってくるオブジェクトは、</p>

<pre><code>{
  apple: 0,
  banana: {
    price: 200
  },
  cherry: 97,
  durian: 100
}
</code></pre>

<p>のようになります。存在しているところは上書きされていますね。</p>

<p>こちらも、詳しくは以下の公式ページに掲載されています。</p>

<p><a href="http://api.jquery.com/jQuery.extend/" target="_blank">http://api.jquery.com/jQuery.extend/</a></p>

<h3 id="dom-enumerations">DOM Enumerations</h3>

<p>最後は、Node オブジェクト（≒DOM ツリーの構成要素）や DOMException オブジェクト（≒例外処理）に対して、 本来あるべき定数を変数として定義しているだけなのですが、 226行目のみ抜粋してみます。</p>

<pre><code>window.Node = window.Node || function Node() { throw TypeError(&quot;Illegal constructor&quot;); };
</code></pre>

<p>グローバルに対して、すでに Node が存在していればそれを使い、 なければ function() { … } を使う、というのは前回までで触れましたが、 その中身では、すぐに例外を投げています。</p>

<p>これは、直接 DOM の要素を new Node() などで作れないようになっており、 DOM ツリーへの要素追加も、document.createElement() を介して要素を生成するようになっているためです。 また、DOM へのアクセスも getElement… や querySelectorAll などからしか出来ないようになっています。</p>

<p>このあたりは HTML を表示しようとした時点で色々勝手にやってくれている部分であり、 ひょっとしたら知る必要はないのかもしれませんが、 とはいえ <strong>window.Node には DOM ツリーを構成する役割があって、少なくとも Node という名前はグローバルで使っているんだ</strong>、 ということくらいは知っておいてもいいのかもしれません。</p>

<p>（※なお、ここで言っている Node というのは、Node.js とは関係しません。あくまで DOM ツリーの構成要素という意味での Node です。）</p>

<h2 id="まとめ">まとめ</h2>

<p>イベントの方まで行けませんでした・・・。</p>

<p>ブログ記事として書き始めたのを若干後悔しています。しばらく（不定期で）続きます。</p>


<ul class="socialbuttons">
  <li class="flow">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja" data-count="vertical">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
  </li>
  <li class="flow">
    <div class="fb-like" data-layout="button" data-action="like" data-size="small" data-show-faces="false" data-share="false"></div>
  </li>
  <li class="flow">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  </li>
</ul>

<div class="poststatus">
  <p>  <time datetime="2014年2月12日">2014年2月12日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/dom/">DOM</a></li>
    <li class="flow"><a href="/tags/javascript/">JavaScript</a></li>
    <li class="flow"><a href="/tags/jquery/">jQuery</a></li>
    <li class="flow"><a href="/tags/polyfills/">polyfills</a></li>
  </ul>
</div>

<small>もし記事内に誤りなどございましたら、 <a href="https://twitter.com/girigiribauer" target="_blank">@girigiribauer</a> までご一報いただけると助かります。</small>

<div class="poststatus">
  <p>  <time datetime="2014年2月2日">2014年2月2日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/ajax/">ajax</a></li>
    <li class="flow"><a href="/tags/javascript/">JavaScript</a></li>
    <li class="flow"><a href="/tags/jquery/">jQuery</a></li>
    <li class="flow"><a href="/tags/jsperf/">jsperf</a></li>
    <li class="flow"><a href="/tags/polyfills/">polyfills</a></li>
  </ul>
</div>




<p>前回からの続きです。 <a href="/archives/1233/">jQuery から卒業するための第1歩を polyfills から学ぼう</a></p>

<p><a href="https://github.com/inexorabletash/polyfill" target="_blank">https://github.com/inexorabletash/polyfill</a> にある web.js をソースコードリーディングしています。 また、es5.js は予め読み込まれている前提となります。</p>

<h2 id="xmlhttprequest-xhr">XMLHttpRequest（XHR）</h2>

<p>いわゆる Ajax の核となる API です。</p>

<p><a href="http://ja.wikipedia.org/wiki/XMLHttpRequest" target="_blank">http://ja.wikipedia.org/wiki/XMLHttpRequest</a></p>

<p>例えば、jQuery を用いてファイルを非同期で取得する場合、 以下のように書いた経験があるかもしれません。</p>

<pre><code>$.ajax({
  type: &quot;POST&quot;,
  url: &quot;some.php&quot;,
  data: { name: &quot;John&quot;, location: &quot;Boston&quot; }
})
</code></pre>

<p><a href="http://api.jquery.com/jQuery.ajax/" target="_blank">http://api.jquery.com/jQuery.ajax/</a> の Examples からの引用です。</p>

<p>この $.ajax の内部で使われているのが、<strong>window.XMLHttpRequest</strong> ですね。</p>

<p>window.XMLHttpRequest は、IE7 から使えるのですが、IE6 以前では使えはするものの、同じ記述ではできません。</p>

<p>23〜37行目を抜粋します。</p>

<pre><code>  //
  // XMLHttpRequest (http://www.w3.org/TR/XMLHttpRequest/)
  //
  window.XMLHttpRequest = window.XMLHttpRequest || function () {
    /*global ActiveXObject*/
    try { return new ActiveXObject(&quot;Msxml2.XMLHTTP.6.0&quot;); } catch (e1) { }
    try { return new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); } catch (e2) { }
    try { return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } catch (e3) { }
    throw Error(&quot;This browser does not support XMLHttpRequest.&quot;);
  };
  XMLHttpRequest.UNSENT = 0;
  XMLHttpRequest.OPENED = 1;
  XMLHttpRequest.HEADERS_RECEIVED = 2;
  XMLHttpRequest.LOADING = 3;
  XMLHttpRequest.DONE = 4;
</code></pre>

<p>ActiveX について掘り下げると本質的ではなくなってしまうのであまり触れませんが、IE6 で Ajax を実現するためには、<strong>ActiveXObject</strong> を用います。</p>

<p>try ~ catch を用いて、試しにオブジェクトを作って上手くいけばそれを採用しています。 try 文の中で、すぐに return するように書かれているので、 new ActiveXObject 部分に問題がなければそのまま function の処理が終わります。 （逆に問題があれば “Illegal return statement” などの SyntaxError が起きますが、catch 文でそのままキャッチアンドリリースしちゃってるので、実際何も起きません。）</p>

<p>その後、XMLHttpRequest オブジェクトに対して、 必要な定数（正確には大文字なだけでただの変数ですが、定数として見なして使っています）を 定義しています。</p>

<p>このあたりの話はかなり使い古されており、もうすでに caniuse.com にすら項目として掲載されていないくらい当たり前の手法となっています。詳しくは以下などをご覧ください。</p>

<p><a href="http://ja.wikipedia.org/wiki/XMLHttpRequest#.E5.88.A9.E7.94.A8.E6.B3.95" target="_blank">http://ja.wikipedia.org/wiki/XMLHttpRequest#.E5.88.A9.E7.94.A8.E6.B3.95</a></p>

<p>なお、<strong>XHR</strong> という略は本当によく使うので、 知らなかった人はこれだけは覚えておいた方が良いと思います。 <strong>XHR = XML Http Request</strong> です。</p>

<h2 id="xmlhttprequest-level-2-xhr2">XMLHttpRequest Level 2 (XHR2)</h2>

<p>上記のパワーアップ版です。</p>

<p>先に42行目、73行目を抜粋します。</p>

<pre><code>  if (!('FormData' in window)) {
  }
</code></pre>

<p>外枠は FormData オブジェクトがあるかどうかで判別をしています。この FormData が一体なんなのか？というのを知るのと同時に、XHR2 でざっくり何が出来るようになったのかを調べてみます。</p>

<p><a href="http://caniuse.com/#feat=xhr2" target="_blank">http://caniuse.com/#feat=xhr2</a></p>

<p><img src="/img/2014/02/polyfills04.png" alt="" /></p>

<p>IE10, iOS5.0, Android3.x, 4.x 以降、その他モダンブラウザで使えるようになったものですが、 <strong>ファイルアップロード時の進捗</strong>を取れたり（progress）、<strong>クロスドメインのリクエスト</strong>などが出来るようになりました。</p>

<p>その他にも、フォームに入力された情報を FormData オブジェクトとして XHR オブジェクトにそのまま渡す仕組みも導入されています。以下に詳しく載ってますが、サンプルコードだけ抜粋します。</p>

<p><a href="http://www.html5rocks.com/ja/tutorials/file/xhr2/#toc-send-formdata" target="_blank">http://www.html5rocks.com/ja/tutorials/file/xhr2/#toc-send-formdata</a></p>

<pre><code>function sendForm() {
  var formData = new FormData();
  formData.append('username', 'johndoe');
  formData.append('id', 123456);

  var xhr = new XMLHttpRequest();
  xhr.open('POST', '/server', true);
  xhr.onload = function(e) { ... };

  xhr.send(formData);
}
</code></pre>

<p>最後の xhr.send(formData) で、FormData オブジェクトを引数にして XHR オブジェクトに渡しているのがなんとなく分かると思います。</p>

<p>という感じで、XHR2 の新しい機能みたいなのは大まかには知ることが出来たと思います。</p>

<h3 id="果たして-xhr2-をすべて-polyfills-として提供できるのか">果たして、XHR2 をすべて polyfills として提供できるのか？</h3>

<p>ここまで読んで、<strong>全部は無理じゃね？</strong>と気づかれた方もいるのではないでしょうか。</p>

<p>クロスドメインのリクエストなんかは、IE8 では非標準の <strong>XDomainRequest</strong> を代用して 実現は出来るのですが、IE7 以前でクロスドメインでファイルのリクエストをするのは難しいです。</p>

<p>自分も日々気をつけたいと思っているのですが、polyfills があるから安易に 「クロスブラウザ対応、問題なくできちゃいます！」と判断しちゃうと、 後で痛い目見ることになると思うので注意が必要です。 <strong>実際に読んで把握したり試したりするのがやっぱり大事ですね。</strong></p>

<p>さっきの抜粋だと、</p>

<pre><code>  if (!('FormData' in window)) {
  }
</code></pre>

<p>FormData オブジェクトがあるかどうかチェックしているため、 FormData オブジェクトに関する polyfills であることが分かります。</p>

<h3 id="即時関数と-jsperf">即時関数と jsperf</h3>

<p>さらにもう内側、43行目、72行目</p>

<pre><code>    (function(global) {
      （中略）
    }(this));
</code></pre>

<p>このように、function （と丸括弧）で挟んでやることで、 引数を渡してすぐにその引数を受け取って実行することが出来るわけですが<strong>（即時関数）</strong>、 this は元々 global であるため、無くてもちゃんと動きます。</p>

<p>何が違うかというと、function の仮引数である global は、function の中だけで有効なローカル変数となっているので、ローカル変数へのアクセスとなり、window オブジェクトへの頻繁なアクセスを避けた方が効率的であるためです。</p>

<p>・・・なんのことを言っているのか分からない人もいると思うので、実際に動かしてみましょう。</p>

<p><strong>jsperf</strong> というサイトがあって、検証コードをその場で試して動かすことが可能です。なお、js の <strong>perf</strong>ormance の略です。 （jsperf に関しては、余裕があればまた改めて記事として書ければなーと思います。）</p>

<p><a href="http://jsperf.com/writing-to-global-objects" target="_blank">http://jsperf.com/writing-to-global-objects</a></p>

<p><img src="/img/2014/02/polyfills05.png" alt="" /></p>

<p>IE8 にて動作させた結果のキャプチャです。</p>

<p>そのまま global として扱った場合と、一度即時関数内でローカル変数として扱った場合とでは、<strong>IE8 にて約5%のパフォーマンスの差異</strong>が出るようです。（もちろんブラウザによって異なります）</p>

<p>なので、こういった頻繁に window オブジェクトにアクセスするようなものは、 予め即時関数でラッピングしてどうこうする、みたいに書かれることが多いですね。勉強になります。</p>

<h3 id="xhr2-の-formdata-オブジェクトの-polyfills">XHR2 の FormData オブジェクトの polyfills</h3>

<p>大分寄り道しましたが、中身を読んでいきます。 とはいえ、全部紹介してたらきりがないので、ポイントだけ抜粋します。</p>

<p>44〜49行目の抜粋です。</p>

<pre><code>      function FormData(form) {
        this._data = [];
        if (!form) return;
        for (var i = 0; i &lt; form.elements.length; ++i)
          this.append(form.elements[i].name, form.elements[i].value);
      }
</code></pre>

<p>new するための FormData オブジェクトを用意しています。 そもそもの FormData オブジェクトの使い方として、引数に HTMLFormElement を取ることが出来るので、引数が無ければそのまま return、あれば append を呼ぶ、となってます。</p>

<p>続いて51〜55行目です。</p>

<pre><code>      FormData.prototype.append = function(name, value /*, filename */) {
        if ('Blob' in global &amp;&amp; value instanceof global.Blob) throw TypeError(&quot;Blob not supported&quot;);
        name = String(name);
        this._data.push([name, value]);
      };
</code></pre>

<p>後追いでフォームの名前と値を追加できるメソッドを用意しています。XHR2 になって、Blob データも送ることが出来るようになったので、Blob 関連の記述もあります。</p>

<p>63行目です。</p>

<pre><code>      global.FormData = FormData;
</code></pre>

<p>global のプロパティに紐付けてやることで、即時関数内で定義したものを外からも呼べるようになります。</p>

<p>最後に64〜71行目の抜粋です。</p>

<pre><code>      var send = global.XMLHttpRequest.prototype.send;
      global.XMLHttpRequest.prototype.send = function(body) {
        if (body instanceof FormData) {
          this.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
          arguments[0] = body.toString();
        }
        return send.apply(this, arguments);
      };
</code></pre>

<p>ここからは、FormData オブジェクトについてではなく、それに関連した既存の XHR オブジェクトの send メソッドの改良についてです。</p>

<p>元々 XHR には send メソッドがあるのですが、新たに FormData も送ることが出来るようになったので、基本の仕組みはそのまま踏襲しつつも、FormData オブジェクトも受け取れるようにしなくてはなりません。</p>

<p>そこで、まず var send = &#8230; として一時的に send 変数に入れておき、 新たに global.XMLHttpRequest.prototype.send として定義して、 FormData オブジェクトだったときの処理を挟みつつ、最後に send.apply で元々の処理を呼んでやるという流れになっています。</p>

<p>・・・とこんな感じで XHR, XHR2 と通信周りを順に読んでみましたが、polyfills を追っていくだけでも色々と勉強になりますね。 いやぁ、けっこう長くなりました。</p>

<h2 id="requestanimationframe">requestAnimationFrame</h2>

<p>お次は requestAnimationFrame です。</p>

<p>HTMLベースのアニメーションは、ほとんどパラパラアニメの仕組みと同じで、 フレームごとに再描画して動いているわけですが、 長らく setTimeout, setInterval などのタイマーを用いてそれが行われていました。</p>

<p>これはもう名前のごとく、アニメーションフレームをリクエストするためのメソッドですね。</p>

<p>詳しい説明はこちらです。</p>

<p><a href="https://developer.mozilla.org/ja/docs/Web/API/window.requestAnimationFrame" target="_blank">https://developer.mozilla.org/ja/docs/Web/API/window.requestAnimationFrame</a></p>

<p>これも元々 setTimeout, setInterval があるので、polyfills として問題なく提供できるはずですね。</p>

<p>流れは XHR とほとんど同じで、即時関数にラッピングして最後に global に紐付けする形です。 requestAnimationFrame が global に紐付けされる前までに、即時関数内だけで使われている処理、94行目から106行目を抜粋します。</p>

<pre><code>    function onFrameTimer() {
      var cur_requests = requests;

      requests = Object.create(null);
      timeout_handle = -1;

      Object.keys(cur_requests).forEach(function(id) {
        var request = cur_requests[id];
        if (!request.element || isVisible(request.element)) {
          request.callback(Date.now());
        }
      });
    }
</code></pre>

<p>これは毎フレームごとに呼ばれる関数となっています。 request は、function のすぐ上に requests = Object.create(null); という変数で用意されており、function 内にも全く同じ記述がされています。</p>

<h3 id="proto-と-console-dir">proto と console.dir</h3>

<p>じゃあ、この Object.create(null) っていうのは一体何やってるのか？というと、 本当の意味で何もない空のオブジェクトを生成しています。</p>

<p>例えば、今開発者ツールを開いて、</p>

<pre><code>var a = Object.create(null);
var b = {};
a === b; // =&gt; ?
</code></pre>

<p>と入力してみると、実際 <strong>false</strong> になります。 そういうときは、例えば <strong>console.dir</strong> などを使ってオブジェクトの中身を詳しく見てみると違いが分かると思います。</p>

<p><img src="/img/2014/02/polyfills06.png" alt="" /></p>

<p>こちらが Firefox での console.dir の表示結果です。</p>

<p><strong>proto</strong> があるかないかの違いが見られます。</p>

<p><img src="/img/2014/02/polyfills07.png" alt="" /></p>

<p>こちらは Chrome での console.dir の表示結果です。（もちろん結果は同じです）</p>

<p>何らかの key, value を持ったオブジェクトを作り、それを for in などでループして何か処理しようとしても、プロトタイプ継承によって余分なプロパティまでもアクセスできてしまいます。それを防ぐために、for in ループの中に Object.prototype.hasOwnProperty を使って自分自身のプロパティでないものは外す、といった定石は有名ですね。</p>

<pre><code>var buz = {
  fog: 'stack'
};

for (var name in buz) {
  if (buz.hasOwnProperty(name)) {
    alert(&quot;this is fog (&quot; + name + &quot;) for sure. Value: &quot; + buz[name]);
  } else {
    alert(name); // toString or something else
  }
}
</code></pre>

<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank">https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty</a> の『例: オブジェクトのプロパティの反復処理』より抜粋</p>

<p>これを実現する別の方法として、何にも継承していない本当に空のオブジェクトを Object.create(null) で作ってやることで、for などでループを回しても継承元がどうこうと考えなくてもよくなります。</p>

<h3 id="requestanimationframe-の残り">requestAnimationFrame の残り</h3>

<p>だいぶ話がそれましたが、Object.keys で cur_requests のキーだけの配列を取得し、それぞれ callback を呼んでいます。</p>

<p>いまいち element が何なのか分からなかったのですが、 （仕様には callback しかなく、第2引数に element を指定するような仕組みはないっぽい・・・）element が無ければ if の中がそのまま実行されるので無視しても良さそうです。</p>

<p>最後に128〜134行目の抜粋です。</p>

<pre><code>    global.requestAnimationFrame =
      global.requestAnimationFrame ||
      global.webkitRequestAnimationFrame ||
      global.mozRequestAnimationFrame ||
      global.oRequestAnimationFrame ||
      global.msRequestAnimationFrame ||
      requestAnimationFrame;
</code></pre>

<p>他のものと同様に、最後に global に紐付けて即時関数の外からも呼べるようにするのですが、 ブラウザの実装度合いによってベンダープレフィックスがついている場合もあるので、それも考慮した書き方になっています。</p>

<p>論理和ごとに順に使えるかどうかチェックして、使えるものがあればそれ、なければ次のものを見ていき、最終的にどれも使えなければ、今即時関数内に用意している requestAnimationFrame を使う、といった流れです。</p>

<h2 id="setimmediate">setImmediate</h2>

<p>似たような API として、今のところ IE だけが対応している setImmediate というのがあります。</p>

<p>ほぼ requestAnimationFrame と同じでそれよりもシンプルなので、 149〜154行目だけ抜粋しておきます。</p>

<pre><code>    function setImmediate(callback/*, args*/) {
      var params = [].slice.call(arguments, 1);
      return global.setTimeout(function() {
        callback.apply(null, params);
      }, 0);
    }
</code></pre>

<p>同様に setTimeout を用いて実現しています。</p>

<p>[].slice.call(arguments, 1) は何をしているかというと、 arguments がその関数内における仮引数のリスト（配列っぽいオブジェクト）に相当するので、 それを実際に配列オブジェクトに用意されている slice メソッドを使って 1つだけ切り出してます。</p>

<p>[0, 1, 2].slice(1) // =&gt; [1, 2] このまま使えばこんな感じですが、arguments はあくまで配列っぽいオブジェクトであるため、 slice メソッドなどは持ち合わせてませんので、call を使って実現しています。</p>

<h2 id="まとめ">まとめ</h2>

<p>はーー、思ったよりも進まない・・・。</p>

<p>ソースコードを読むこと自体は、そんなに時間のかかる行為ではないんですが、それをブログに説明として分かりやすく載せるとなると、意外に時間かかっちゃうものですね。</p>

<p>たぶんその4、その5あたりまで行っちゃうかもしれません。</p>

<p>お次は DOM 周りの polyfills です。イベントもいけたらいいな。</p>

<p>追記：<a href="/archives/1269/">続き書きました。</a></p>


<ul class="socialbuttons">
  <li class="flow">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja" data-count="vertical">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
  </li>
  <li class="flow">
    <div class="fb-like" data-layout="button" data-action="like" data-size="small" data-show-faces="false" data-share="false"></div>
  </li>
  <li class="flow">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  </li>
</ul>

<div class="poststatus">
  <p>  <time datetime="2014年2月2日">2014年2月2日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/ajax/">ajax</a></li>
    <li class="flow"><a href="/tags/javascript/">JavaScript</a></li>
    <li class="flow"><a href="/tags/jquery/">jQuery</a></li>
    <li class="flow"><a href="/tags/jsperf/">jsperf</a></li>
    <li class="flow"><a href="/tags/polyfills/">polyfills</a></li>
  </ul>
</div>

<small>もし記事内に誤りなどございましたら、 <a href="https://twitter.com/girigiribauer" target="_blank">@girigiribauer</a> までご一報いただけると助かります。</small>

<div class="poststatus">
  <p>  <time datetime="2014年1月30日">2014年1月30日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/javascript/">JavaScript</a></li>
    <li class="flow"><a href="/tags/jquery/">jQuery</a></li>
    <li class="flow"><a href="/tags/polyfills/">polyfills</a></li>
  </ul>
</div>




<p>jQuery というライブラリは非常に便利な JavaScript ライブラリであります。</p>

<h2 id="jquery-便利">jQuery 便利！</h2>

<p>いやー、便利ですよね。便利すぎて、JavaScript を書いてHTML要素を何かしようと思ったときに、無条件で使用してしまうケースもけっこう多いのではないでしょうか。</p>

<p>ただ、知っている人は、jQuery のファイルサイズが若干重いことも知っています。</p>

<p>2014年2月時点での jQuery の最新バージョンでファイルサイズを見てみると、</p>

<ul>
<li>jquery-1.11.0.js (277KB)</li>
<li>jquery-1.11.0.min.js (95KB)</li>
<li>jquery-2.1.0.js (240KB)</li>
<li>jquery-2.1.0.min.js (82KB)</li>
</ul>

<p>IE8未満をばっさり切った 2.x 系だと、圧縮したもので 82KB あります。IE8未満も含めた 1.x 系だと、圧縮したもので 95KB もあります。</p>

<p>また、jQuery にはプラグイン機構があるため、ライブラリのファイルに続けて、プラグイン用のファイルをいくつか読み込むことが多いと思います。</p>

<p>ファイルサイズの問題うんぬんもあるのですが、それに加えて<strong>同時リクエスト数の問題</strong>もあります。例えば画像ファイルなどであれば、例えば6ファイルなどを同時にリクエストすることが出来ますが、スクリプトのファイルだと、実行順などの問題もあるので、<strong>スクリプトファイルを読み込んでいる最中は他スクリプトがストップしてしまう</strong>ので、あれこれとプラグイン用のファイルを読み込んでいると、いつまでたっても全体の処理が終わらないことになります。</p>

<p>そのあたりの説明は、以下に詳しく載ってます。</p>

<p><a href="https://developers.google.com/speed/docs/best-practices/rtt?hl=ja&amp;csw=1#CombineExternalJS" target="_blank">https://developers.google.com/speed/docs/best-practices/rtt?hl=ja&amp;csw=1#CombineExternalJS</a></p>

<h3 id="jquery-は甘え-という風潮">「jQuery は甘え」という風潮</h3>

<p>便利なライブラリである一方で、安易に使いまくる人に対して、甘えだーという人も一定数居ます。</p>

<p>個人的には、無理に使用を縛らずケースバイケースで普通に使っていくべきだとは思いますが、 ちょっとした処理をしたいときに毎回 「jQuery がないとダメ、何にもできない・・・。」みたいなのも少しずつ改めていくべきだとは思います。</p>

<p>例えば、class=”toggle” がついている要素を取得して何かしたい場合、 jQuery であれば以下のように書きます。</p>

<pre><code>var toggles = $('.toggle');
</code></pre>

<p>ただ、これくらいであれば、jQuery を介さずとも簡単に取得できます。</p>

<pre><code>var toggles = document.querySelectorAll('.toggle');
</code></pre>

<p>どちらもそれほど変わらない記述で class=”toggle” を含む要素を取得できるので、その後の処理によってはわざわざ jQuery を読み込まずとも、素の JavaScript でも問題なかったりしますね。</p>

<h3 id="クロスブラウザという現実的な問題">クロスブラウザという現実的な問題</h3>

<p>・・・という理想郷の話だったわけですが、現実はそう簡単にはいかないケースも多いです。</p>

<p>jQuery が吸収してくれているのは、こういったブラウザ間の JavaScript の実装差異だったりします。</p>

<p>例えば、先ほど書いた document.querySelectorAll の例ですが、 IE8未満では実はサポートされていません。</p>

<p><a href="http://caniuse.com/#feat=queryselector" target="_blank">http://caniuse.com/#feat=queryselector</a></p>

<p><img src="/img/2014/01/polyfills01.png" alt="" /></p>

<p>この例だと、たまたま IE8 以上か IE7 以下かで分けられるので、 IE7 以前なんていいじゃん、というケースも出てくるかもしれませんが、 ブラウザの対応度合いは様々なので、その都度対応しているかどうかを考えて、 この場合はこうして・・・などと毎回考えていくのはあまり本質的ではありませんね。 やりたいことを解決するために時間を使った方が良いと思います。</p>

<h2 id="jquery-から卒業するための第1歩を-polyfills-から学ぼう">jQuery から卒業するための第1歩を polyfills から学ぼう</h2>

<p>そこで本記事のタイトルです。</p>

<p><strong>polyfills（ポリフィル）</strong>というのは、数年前から言われている概念なので、 知っている人もいくらかいるのではないかと思いますが、 モダンブラウザで普通に出来て、レガシーブラウザで出来ない機能を、既存の技術で（あるいはそれらの組み合わせで）同等のものを提供する、という手法です。</p>

<p>※ちなみに fallback（フォールバック）は、提供が難しいものに対してそれに近しいもので代替することを指すので、ちょっと違うと思います。</p>

<p>つまり、polyfills を利用して、レガシーブラウザ用に機能が足りてない部分を 補完してやることで、レガシーブラウザの場合にああしてこうして・・・といった部分の 考えるコストを一定低減することが出来ます。</p>

<h3 id="polyfills-を知ることでブラウザの実装の歴史を知る">polyfills を知ることでブラウザの実装の歴史を知る</h3>

<p>色んな方が polyfills を公開しています。</p>

<p>まとめられているページがこちら。</p>

<p><a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills" target="_blank">https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills</a></p>

<p>たくさんあるのですが、今回読んだのがこちら。</p>

<p><a href="https://github.com/inexorabletash/polyfill" target="_blank">https://github.com/inexorabletash/polyfill</a></p>

<p><img src="/img/2014/01/polyfills02.png" alt="" /></p>

<p>こちらでは、例えば JavaScript の仕様である ECMAScript の、 バージョン5に相当する ECMAScript5 (ES5) と見比べて、 不足している実装部分を <strong>es5.js</strong> として提供されていたり、 あるいは バイナリデータ（映像、音声など）を効率良く扱うための Typed Array の polyfills が <strong>typedarray.js</strong> として提供されていたりします。</p>

<p><img src="/img/2014/01/polyfills03.png" alt="" /></p>

<p>その中で、<strong>Web Standards / Browser</strong> として提供されている polyfills、<strong>web.js</strong> というのがあります。</p>

<p>こちらは、上記に挙げたようなある特定の仕様に対して不足があるかどうか？というよりは、一般的に Web 標準で考えた場合に不足があるかどうか？を元に polyfills がまとめられています。 なので、こちらのコードを追っていくことで<strong>逆にブラウザの実装の歴史が分かるのではないでしょうか。</strong></p>

<p>・・・ということで、前振りが長かったですが、一言で言うと、<strong>『このリポジトリの web.js というファイルを順に読んでブラウザの実装差異について理解していこう！』</strong>という記事になります。</p>

<h2 id="polyfills-のソースコードリーディングを始めよう">polyfills のソースコードリーディングを始めよう</h2>

<p>早速10行目と613行目を抜粋します。</p>

<pre><code>if ('window' in this &amp;&amp; 'document' in this) {
  //（中略）
}
</code></pre>

<p>this は、通常ブラウザで読み込むと global に相当しますので、global に window と document がある場合にのみ処理されます。（要するに処理されます）</p>

<p>次は、18行目から21行目です。簡単なところから始まってて（ブログ書きやすくて）良かったですね。</p>

<pre><code>//
// document.head (HTML5)
//
</code></pre>

<p>document.head = document.head || document.getElementsByTagName(&#8216;head&#8217;)[0]; 僕これ知らなかったのですが、HTML5 だと document オブジェクトに head プロパティがあり、 それが HTML 内の head 要素を指すのですね。</p>

<p>対応しているものは、document.head がそのまま使われるのですが、対応してないものは undefined を返すので、|| の後ろが実行されます。</p>

<p>document.getElementsByTagName は、getElementById と同じく 古いIEでも普通に使えます。 読んで字のごとく、要素（複数）をタグ名で取得するってことで、 head 要素を取得してから、それの一番最初のやつを使いますってことですね。</p>

<p>このように論理和（||）を用いて実装の差異を埋めてやることで、polyfills を上手く実現していることが見てとれます。</p>

<h2 id="まとめ">まとめ</h2>

<p>ちょっと前振りが長かったので一旦切りたいと思います。</p>

<p>このように、polyfills を順に追っていくことで、ブラウザの実装の歴史を知るのもなかなかお手軽で良いのではないでしょうか。</p>

<p>こちらのコードに書かれているような実装差異の吸収の仕方、テクニックを見ていくことで、ついでに自分が書くときにもプラスになるのでは？と思うので、これから順に見ていきたいと思います。</p>

<p>なお、最初の8行のコメントにもあるように、</p>

<pre><code>//----------------------------------------------------------------------
//
// Browser Polyfills
//
// This assumes ES5 or ES3 + es5.js
// (polyfill.js is es5.js + web.js for convenience)
//
//----------------------------------------------------------------------
</code></pre>

<p>正確には polyfill.js 全体が es5.js と web.js の組み合わせで出来ていますが、今回は ES5 に注目して読むよりも、Web Standards な方に注目して見てみたい、という意図があったので、web.js の方を見ています。</p>

<p>なので、このまま読んでいくと、ES5 前提の記述をちらほら見かけます。これは予め es5.js の機能を読み込んでいるためです。次回以降の続きの記事でたぶん出てきますので予めご了承ください。</p>

<p>たぶん続きます。</p>

<p>追記： <a href="/archives/1254/">続き書きました。</a></p>


<ul class="socialbuttons">
  <li class="flow">
    <a href="https://twitter.com/share" class="twitter-share-button" data-lang="ja" data-count="vertical">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
  </li>
  <li class="flow">
    <div class="fb-like" data-layout="button" data-action="like" data-size="small" data-show-faces="false" data-share="false"></div>
  </li>
  <li class="flow">
    <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
  </li>
</ul>

<div class="poststatus">
  <p>  <time datetime="2014年1月30日">2014年1月30日</time>
</p>

  <ul class="tags">
    <li class="flow"><a href="/tags/javascript/">JavaScript</a></li>
    <li class="flow"><a href="/tags/jquery/">jQuery</a></li>
    <li class="flow"><a href="/tags/polyfills/">polyfills</a></li>
  </ul>
</div>

<small>もし記事内に誤りなどございましたら、 <a href="https://twitter.com/girigiribauer" target="_blank">@girigiribauer</a> までご一報いただけると助かります。</small>







</div>

<footer>

<h2>Tags</h2>

<ul class="tags">
  <li class="flow">
    <a href="/tags/ansible">Ansible (5)</a>
  </li>
  <li class="flow">
    <a href="/tags/apache">Apache (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/cli">CLI (10)</a>
  </li>
  <li class="flow">
    <a href="/tags/css">CSS (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/css3">CSS3 (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/cssfilter">CSSfilter (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/canvas">Canvas (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/chef">Chef (9)</a>
  </li>
  <li class="flow">
    <a href="/tags/crawler">Crawler (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/dom">DOM (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/docker">Docker (5)</a>
  </li>
  <li class="flow">
    <a href="/tags/ftp">FTP (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/font">Font (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/functionallanguage">FunctionalLanguage (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/glsl">GLSL (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/git">Git (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/golang">Golang (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/html">HTML (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/html5">HTML5 (7)</a>
  </li>
  <li class="flow">
    <a href="/tags/html5-outline">HTML5-outline (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/homebrew">Homebrew (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/hugo">Hugo (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/icon-font">Icon-Font (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/javascript">JavaScript (5)</a>
  </li>
  <li class="flow">
    <a href="/tags/linux">Linux (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/mvc">MVC (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/opengraph">OpenGraph (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/php">PHP (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/rdfa">RDFa (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/ssh">SSH (4)</a>
  </li>
  <li class="flow">
    <a href="/tags/svg">SVG (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/scala">Scala (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/shellscript">ShellScript (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/smartphone">Smartphone (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/static-site-generator">Static Site Generator (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/vagrant">Vagrant (15)</a>
  </li>
  <li class="flow">
    <a href="/tags/vim">Vim (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/virtualbox">VirtualBox (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/virtualization">Virtualization (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webapp">WebApp (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webaudioapi">WebAudioAPI (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webfont">WebFont (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webgl">WebGL (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webrtc">WebRTC (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/webserver">WebServer (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/yeoman">Yeoman (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/zsh">Zsh (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/ajax">ajax (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/automation">automation (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/bugs">bugs (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/event-conference">event-conference (5)</a>
  </li>
  <li class="flow">
    <a href="/tags/getusermedia">getUserMedia (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/gitconfig">gitconfig (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/ios">iOS (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/iterm">iTerm (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/jquery">jQuery (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/jinja2">jinja2 (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/jq">jq (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/jsperf">jsperf (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/mediaquery">mediaQuery (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/namespace">namespace (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/oldie">oldIE (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/output">output (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/polyfills">polyfills (4)</a>
  </li>
  <li class="flow">
    <a href="/tags/preloader">preloader (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/rsync">rsync (1)</a>
  </li>
  <li class="flow">
    <a href="/tags/tmux">tmux (3)</a>
  </li>
  <li class="flow">
    <a href="/tags/viewport">viewport (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/vimrc">vimrc (2)</a>
  </li>
  <li class="flow">
    <a href="/tags/virtualization">virtualization (6)</a>
  </li>
  <li class="flow">
    <a href="/tags/wget">wget (1)</a>
  </li>
</ul>

<h2>Categories</h2>

<ul>
  <li>
    <a href="/categories/tech/">Category / Tech</a>
  </li>
  <li>
    <a href="/categories/twentyfour/">Category / TwentyFour</a>
  </li>
</ul>

<h2>RSS</h2>

<ul>
  <li>
    <a href="/categories/tech/index.xml" target="_blank">RSS: Category / Tech</a>
  </li>
  <li>
    <a href="/index.xml" target="_blank">RSS: All articles</a>
  </li>
</ul>

<p>このブログは個人の見解であり、所属する組織の公式見解ではありません</p>
<p>&copy; ばうあーろぐ Generated by <a href="https://gohugo.io/" target="_blank">Hugo</a> and <a href="https://github.com/sindresorhus/github-markdown-css" target="_blank">github-markdown-css</a></p>

</footer>

</div>


<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-36767095-1']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>



  </body>
</html>


